---
title: "Search Strategies"
description: "How solutions are explored and selected"
---

## Overview

Search strategies control how Kapso explores the solution space. They generate solution candidates, run experiments, and track results.

## Available Strategies

| Strategy | Description | Best For |
|----------|-------------|----------|
| `linear_search` | One solution per iteration | Simple problems, quick testing |
| `llm_tree_search` | Tree-based exploration | Complex problems, diverse solutions |

## Linear Search

The simplest strategy: generate one solution per iteration.

```mermaid
flowchart LR
    A[Generate Solution] --> B[Implement Code]
    B --> C[Run & Evaluate]
    C --> D[Record Result]
    D --> A
```

### Configuration

```yaml
search_strategy:
  type: "linear_search"
  params:
    code_debug_tries: 5
    idea_generation_model: "gpt-4o-mini"
```

### Usage

```python
from src.execution.search_strategies import SearchStrategyFactory

strategy = SearchStrategyFactory.create(
    strategy_type="linear_search",
    problem_handler=handler,
    llm=llm,
    coding_agent_config=config,
    params={"code_debug_tries": 5},
)

strategy.run(context, budget_progress=0.0)
best = strategy.get_best_experiment()
```

## LLM Tree Search

Advanced strategy that explores solutions as a tree structure.

```mermaid
flowchart TB
    ROOT["Root"]
    N1["Node 1: Approach A"]
    N2["Node 2: Approach B"]
    N3["Node 3: A + optimization"]
    N4["Node 4: A + different data"]

    ROOT --> N1
    ROOT --> N2
    N1 --> N3
    N1 --> N4

    N3 -.->|"best: 0.92"| BEST["Best Result"]
```

### Algorithm

Each iteration:
1. **Prune**: Remove unpromising solutions (after 20% budget)
2. **Expand**: Generate new child solutions from selected nodes
3. **Select**: Pick best nodes to experiment with
4. **Run**: Execute experiments in parallel

```python
def run(self, context, budget_progress):
    # Prune after initial exploration
    if budget_progress >= 20:
        self.prune_bad_solutions(context)

    # Expand nodes with new solutions
    self.expand(context, budget_progress)

    # Select best nodes to experiment
    best_nodes = self.select(
        context,
        top_k=experiments_count,
        exclude_experimented_nodes=True
    )

    # Run experiments in parallel
    with ThreadPoolExecutor() as executor:
        for node in best_nodes:
            executor.submit(self._run_for_node, node, context, branch_name)
```

### Configuration

```yaml
search_strategy:
  type: "llm_tree_search"
  params:
    reasoning_effort: "medium"
    code_debug_tries: 5
    node_expansion_limit: 2
    node_expansion_new_childs_count: 5
    idea_generation_steps: 1
    first_experiment_factor: 1
    experimentation_per_run: 1
    per_step_maximum_solution_count: 10
    exploration_budget_percent: 30
    idea_generation_model: "gpt-4o-mini"
```

### Parameters

| Parameter | Default | Description |
|-----------|---------|-------------|
| `node_expansion_limit` | 2 | Nodes to expand per iteration |
| `node_expansion_new_childs_count` | 5 | Solutions generated per expansion |
| `code_debug_tries` | 5 | Max debug attempts per solution |
| `exploration_budget_percent` | 30 | When to switch to exploitation |
| `idea_generation_model` | `gpt-4.1-mini` | Model for solution generation |
| `experimentation_per_run` | 1 | Experiments per iteration |
| `first_experiment_factor` | 1 | Multiplier for first iteration |

### Exploration vs Exploitation

```mermaid
flowchart LR
    subgraph Exploration["Exploration (0-30%)"]
        E1["Diverse solutions"]
        E2["LLM selects by potential"]
    end

    subgraph Exploitation["Exploitation (30-100%)"]
        X1["Focus on top scorers"]
        X2["Refine best solutions"]
    end

    Exploration -->|"budget > 30%"| Exploitation
```

## Node Structure (SearchNode)

```python
@dataclass
class SearchNode:
    node_id: int
    parent_node_id: Optional[int] = None
    
    # Step 1: Solution generation
    solution: str = ""
    
    # Step 2: Implementation
    branch_name: str = ""
    code_changes_summary: str = ""
    
    # Step 3: Evaluation
    evaluation_script_path: str = ""
    evaluation_output: str = ""
    
    # Step 4: Feedback
    feedback: str = ""
    score: Optional[float] = None
    should_stop: bool = False
    evaluation_valid: bool = True
    
    # Metadata
    had_error: bool = False
    error_message: str = ""
    workspace_dir: str = ""
```

## Benchmark Tree Search

For benchmarks (MLE-Bench, ALE-Bench), use `benchmark_tree_search` which uses the handler's built-in evaluation:

```yaml
# benchmarks/mle/config.yaml
search_strategy:
  type: "benchmark_tree_search"  # Uses handler.run() for evaluation
```

| Strategy | Evaluation | Stop Decision | Use Case |
|----------|------------|---------------|----------|
| `llm_tree_search` | Agent-built | Feedback generator | `kapso.evolve()` |
| `linear_search` | Agent-built | Feedback generator | Simple problems |
| `benchmark_tree_search` | Handler's `run()` | Handler's `stop_condition()` | MLE/ALE benchmarks |

## Creating Custom Strategies

```python
from src.execution.search_strategies.base import SearchStrategy
from src.execution.search_strategies.factory import register_strategy

@register_strategy("my_custom_search")
class MyCustomSearch(SearchStrategy):
    def __init__(self, config, workspace_dir=None):
        super().__init__(config, workspace_dir)
        # Custom initialization

    def run(self, context, budget_progress=0.0):
        # Generate and run experiments
        solution = self.generate_solution(context)
        result = self._implement_n_debug(
            solution, context,
            code_debug_tries=5,
            branch_name="experiment_0",
        )
        self.experiment_history.append(result)

    def get_experiment_history(self, best_last=False):
        if best_last:
            return sorted(self.experiment_history, key=lambda x: x.score)
        return self.experiment_history

    def get_best_experiment(self):
        valid = [e for e in self.experiment_history if not e.had_error]
        return max(valid, key=lambda x: x.score) if valid else None

    def checkout_to_best_experiment_branch(self):
        best = self.get_best_experiment()
        if best:
            self.workspace.switch_branch(best.branch_name)
```

## Shared Implementation

All strategies inherit from `SearchStrategy` base class:

### implement_solution

```python
def implement_solution(self, solution, context, session):
    # Build prompt with RepoMemory context
    repo_memory_brief = RepoMemoryManager.render_summary_and_toc(...)

    prompt = render_prompt(template, {
        "problem": context.problem,
        "solution": solution,
        "repo_memory_brief": repo_memory_brief,
        "kg_code_results": context.kg_code_results,
    })

    # Agent implements AND runs evaluation
    session.generate_code(prompt)
    
    # Extract structured JSON from agent output
    return self._extract_agent_result(session.output)
```

### _extract_agent_result

```python
def _extract_agent_result(self, agent_output: str) -> dict:
    """
    Extract structured JSON result from agent output.
    
    Looks for JSON block at the end of the output:
    ```json
    {"code_changes_summary": "...", ...}
    ```
    """
    # Find and parse JSON from agent output
    ...
```

### _generate_feedback

```python
def _generate_feedback(self, node: SearchNode) -> FeedbackResult:
    """
    Generate feedback for the node using FeedbackGenerator.
    """
    return self.feedback_generator.generate(
        goal=self.goal,
        idea=node.solution,
        implementation=node.code_changes_summary,
        evaluation_result=node.evaluation_output,
    )
```

### debug_solution

```python
def debug_solution(self, solution, context, error, session):
    prompt = render_prompt(debug_template, {
        "problem": context.problem,
        "solution": solution,
        "error_details": error,
    })

    session.generate_code(prompt, debug_mode=True)
```

### _implement_n_debug

```python
def _implement_n_debug(self, solution, context, code_debug_tries, branch_name):
    session = self.workspace.create_experiment_session(branch_name)
    node = self.implement_solution(solution, context, session)

    for i in range(code_debug_tries):
        if node.had_error:
            node = self.debug_solution(solution, context, node.error_message, session)
        else:
            break

    # Generate feedback
    feedback_result = self._generate_feedback(node)
    node.feedback = feedback_result.feedback
    node.score = feedback_result.score
    node.should_stop = feedback_result.stop

    # Update RepoMemory
    session.schedule_repo_memory_update(solution_spec=solution, run_result=node)
    self.workspace.finalize_session(session)

    return node
```